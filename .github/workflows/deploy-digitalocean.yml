# GitHub Actions - D√©ploiement automatique sur DigitalOcean
#
# Configuration requise:
# 1. Cr√©er les secrets dans GitHub Settings > Secrets and variables > Actions:
#    - DO_SSH_PRIVATE_KEY: Votre cl√© SSH priv√©e (contenu complet)
#    - DROPLET_IP: IP publique du droplet (obtenue apr√®s terraform apply)
#    - WEATHERAPI_KEY: Cl√© API WeatherAPI
#    - ANTHROPIC_API_KEY: Cl√© API Anthropic
#    - OPENROUTESERVICE_TOKEN: Cl√© API OpenRouteService
#    - ENV_GITHUB_TOKEN: GitHub token pour cloner le d√©p√¥t priv√© planMyTrip (.env)
#
# 2. S'assurer que la cl√© SSH publique correspondante est sur le droplet
#
# 3. Push vers main pour d√©clencher le d√©ploiement

name: Deploy to DigitalOcean

on:
  push:
    branches: [main]
  workflow_dispatch: # Permet d√©clenchement manuel

env:
  NODE_VERSION: "20"
  PNPM_VERSION: "10"
  RUST_VERSION: "stable"

jobs:
  # Job 1: Build et test
  build:
    name: Build and Test
    runs-on: ubuntu-latest
    env:
      OPENROUTESERVICE_TOKEN: ${{ secrets.OPENROUTESERVICE_TOKEN }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Get pnpm store directory
        id: pnpm-cache
        run: echo "STORE_PATH=$(pnpm store path)" >> $GITHUB_OUTPUT

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('frontend/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install frontend dependencies
        working-directory: ./frontend
        run: pnpm install --frozen-lockfile

      - name: Build frontend
        working-directory: ./frontend
        run: pnpm run build

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: ${{ env.RUST_VERSION }}

      - name: Setup Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          cache-on-failure: true

      - name: Build backend (Rust)
        env:
          SQLX_OFFLINE: true
        run: cargo build --release

      - name: Upload frontend artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist
          path: frontend/dist/
          retention-days: 1

      - name: Upload backend artifacts
        uses: actions/upload-artifact@v4
        with:
          name: backend
          path: target/release/actix_sqlx_template
          retention-days: 1

  # Job 2: D√©ployer sur DigitalOcean Droplet
  deploy-droplet:
    name: Deploy to Droplet
    needs: build
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download frontend artifacts
        uses: actions/download-artifact@v4
        with:
          name: dist
          path: dist/

      - name: Download backend artifacts
        uses: actions/download-artifact@v4
        with:
          name: backend
          path: backend/

      - name: Clone .env repository
        env:
          ENV_GITHUB_TOKEN: ${{ secrets.ENV_GITHUB_TOKEN }}
        run: |
          echo "üì¶ Cloning .env repository..."
          if [ -z "$ENV_GITHUB_TOKEN" ]; then
            echo "‚ö†Ô∏è  ENV_GITHUB_TOKEN not configured, skipping .env deployment"
            echo "To enable .env deployment, add ENV_GITHUB_TOKEN secret in GitHub Settings"
            mkdir -p env-repo
            echo "# Placeholder .env file" > env-repo/.env
          else
            git clone https://git:$ENV_GITHUB_TOKEN@github.com/ctaque/planMyTrip.git env-repo
            if [ ! -f env-repo/.env ]; then
              echo "‚ùå .env file not found in planMyTrip repository!"
              exit 1
            fi
            echo "‚úÖ .env file retrieved from planMyTrip repository"
          fi

      - name: Check droplet configuration
        id: check-secrets
        run: |
          if [ -z "${{ secrets.DROPLET_IP }}" ] || [ -z "${{ secrets.DO_SSH_PRIVATE_KEY }}" ]; then
            echo "configured=false" >> $GITHUB_OUTPUT
            echo ""
            echo "‚ÑπÔ∏è  Droplet deployment is not configured"
            echo ""
            echo "To enable deployment, add these secrets in GitHub Settings:"
            echo "  Settings > Secrets and variables > Actions > New repository secret"
            echo ""
            echo "Required secrets:"
            echo "  - DROPLET_IP: Your droplet public IP address"
            echo "  - DO_SSH_PRIVATE_KEY: Your SSH private key content"
            echo ""
            echo "Get the droplet IP after running: terraform apply"
            echo ""
          else
            echo "configured=true" >> $GITHUB_OUTPUT
          fi

      - name: Setup SSH
        if: steps.check-secrets.outputs.configured == 'true'
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DO_SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          # Test SSH connectivity
          echo "Testing connection to ${{ secrets.DROPLET_IP }}..."
          if timeout 10 bash -c "echo > /dev/tcp/${{ secrets.DROPLET_IP }}/22" 2>/dev/null; then
            echo "‚úÖ Port 22 is reachable"
            ssh-keyscan -H -T 10 ${{ secrets.DROPLET_IP }} >> ~/.ssh/known_hosts 2>&1 || {
              echo "‚ö†Ô∏è  ssh-keyscan failed, using permissive config"
              echo "StrictHostKeyChecking no" >> ~/.ssh/config
              echo "UserKnownHostsFile /dev/null" >> ~/.ssh/config
            }
          else
            echo "‚ùå Cannot connect to ${{ secrets.DROPLET_IP }}:22"
            echo ""
            echo "Possible issues:"
            echo "  1. Droplet may be stopped"
            echo "  2. Firewall blocking SSH"
            echo "  3. Incorrect DROPLET_IP secret"
            exit 1
          fi

      - name: Deploy to Droplet
        if: steps.check-secrets.outputs.configured == 'true'
        env:
          DROPLET_IP: ${{ secrets.DROPLET_IP }}
          OPENROUTESERVICE_TOKEN: ${{ secrets.OPENROUTESERVICE_TOKEN }}
        run: |
          # Create deployment archive in /tmp to avoid "file changed" error
          echo "üì¶ Creating deployment archive..."
          tar -czf /tmp/app.tar.gz \
            --exclude=node_modules \
            --exclude=.git \
            --exclude=terraform \
            --exclude=.github \
            --exclude=dist \
            --exclude=target \
            .

          # Upload to droplet
          echo "üì§ Uploading to droplet..."
          scp -i ~/.ssh/deploy_key /tmp/app.tar.gz root@$DROPLET_IP:/tmp/

          # Make backend binary executable and upload it
          chmod +x backend/actix_sqlx_template
          scp -i ~/.ssh/deploy_key backend/actix_sqlx_template root@$DROPLET_IP:/tmp/backend_binary

          # Upload .env file
          echo "üì§ Uploading .env file..."
          scp -i ~/.ssh/deploy_key env-repo/.env root@$DROPLET_IP:/tmp/app.env

          # Deploy on droplet
          echo "üöÄ Deploying application..."
          ssh -i ~/.ssh/deploy_key root@$DROPLET_IP << 'ENDSSH'
            set -e

            # Switch to planmytrip user
            sudo -u planmytrip bash << 'EOF'
              cd /home/planmytrip/app

              # Backup current version
              echo "üíæ Creating backup..."
              mkdir -p /home/planmytrip/backups
              tar -czf /home/planmytrip/backups/app-$(date +%Y%m%d-%H%M%S).tar.gz . || true

              # Extract new version
              echo "üì¶ Extracting new version..."
              tar -xzf /tmp/app.tar.gz

              # Update .env file from uploaded file
              if [ -f /tmp/app.env ]; then
                echo "üîê Updating .env file..."
                cp /tmp/app.env .env
                chmod 600 .env
                echo "‚úÖ .env file updated"
              else
                echo "‚ö†Ô∏è  No .env file to update"
              fi

              # Install all dependencies (including devDependencies for build)
              echo "üì• Installing frontend dependencies..."
              cd frontend
              pnpm install

              # Build frontend
              echo "üî® Building frontend..."
              pnpm run build

              # Remove devDependencies after build
              echo "üßπ Cleaning devDependencies..."
              pnpm prune --prod
              cd ..

              echo "‚úÖ Application files updated!"
          EOF

          # Deploy backend binary as root (needs permission to write to /home/planmytrip/app)
          echo "ü¶Ä Deploying Rust backend..."
          echo "‚è∏Ô∏è  Stopping service to replace binary..."
          systemctl stop planmytrip

          chmod +x /tmp/backend_binary
          cp /tmp/backend_binary /home/planmytrip/app/actix_sqlx_template
          chown planmytrip:planmytrip /home/planmytrip/app/actix_sqlx_template
          chmod +x /home/planmytrip/app/actix_sqlx_template

          # Fix SELinux context if SELinux is enabled
          if command -v getenforce &> /dev/null && [ "$(getenforce)" != "Disabled" ]; then
            echo "üîí Restoring SELinux context..."
            restorecon -v /home/planmytrip/app/actix_sqlx_template || chcon -t bin_t /home/planmytrip/app/actix_sqlx_template
          fi

          # Start systemd service as root
          echo "‚ñ∂Ô∏è  Starting application service..."
          systemctl start planmytrip
          sleep 3
          systemctl status planmytrip --no-pager

          # Cleanup
          rm -f /tmp/app.tar.gz /tmp/backend_binary /tmp/app.env

          echo "‚úÖ Deployment successful!"
          ENDSSH

      - name: Health check
        if: steps.check-secrets.outputs.configured == 'true'
        env:
          DROPLET_IP: ${{ secrets.DROPLET_IP }}
        run: |
          # Wait for app to start
          echo "‚è≥ Waiting for application to start..."
          sleep 10

          # Test HTTPS endpoint (with -k to ignore self-signed cert warnings)
          echo "üè• Running health check..."
          HTTP_CODE=$(curl -k -s -o /dev/null -w "%{http_code}" https://$DROPLET_IP)

          if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "304" ]; then
            echo "‚úÖ Deployment successful! HTTP $HTTP_CODE"
            echo "üåê Application URL: https://$DROPLET_IP"
          else
            echo "‚ùå Health check failed! HTTP $HTTP_CODE"
            echo "Check application logs on the droplet:"
            echo "  ssh root@$DROPLET_IP 'journalctl -u planmytrip -n 50'"
            exit 1
          fi

  # Job 3: Notification
  notify:
    name: Notify
    needs: [build, deploy-droplet]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Deployment status
        run: |
          BUILD_RESULT="${{ needs.build.result }}"
          DEPLOY_RESULT="${{ needs.deploy-droplet.result }}"

          echo "üìä Deployment Summary"
          echo "===================="
          echo "Build: $BUILD_RESULT"
          echo "Deploy: $DEPLOY_RESULT"
          echo ""

          if [ "$BUILD_RESULT" == "success" ]; then
            echo "‚úÖ Build succeeded!"
          else
            echo "‚ùå Build failed!"
            exit 1
          fi

          if [ "$DEPLOY_RESULT" == "success" ]; then
            echo "‚úÖ Droplet deployment succeeded!"
          elif [ "$DEPLOY_RESULT" == "skipped" ]; then
            echo "‚è≠Ô∏è  Droplet deployment skipped (secrets not configured)"
          else
            echo "‚ùå Droplet deployment failed!"
            exit 1
          fi
